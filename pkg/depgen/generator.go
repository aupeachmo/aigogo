package depgen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/aupeachmo/aigogo/pkg/manifest"
)

// Generator generates dependency files for different languages
type Generator struct{}

// NewGenerator creates a new dependency file generator
func NewGenerator() *Generator {
	return &Generator{}
}

// Generate creates appropriate dependency files based on manifest
func (g *Generator) Generate(m *manifest.Manifest, outputDir string) ([]string, error) {
	if m.Dependencies == nil {
		return nil, nil // No dependencies to generate
	}

	switch m.Language.Name {
	case "python":
		return g.generatePython(m, outputDir)
	case "javascript":
		return g.generateJavaScript(m, outputDir)
	case "go":
		return g.generateGo(m, outputDir)
	case "rust":
		return g.generateRust(m, outputDir)
	default:
		return nil, fmt.Errorf("unsupported language: %s", m.Language.Name)
	}
}

// Python generation
func (g *Generator) generatePython(m *manifest.Manifest, outputDir string) ([]string, error) {
	var files []string

	// Generate requirements.txt
	reqPath := filepath.Join(outputDir, "requirements.txt")
	if err := g.writePythonRequirements(reqPath, m.Dependencies.Runtime); err != nil {
		return nil, err
	}
	files = append(files, "requirements.txt")

	// Generate pyproject.toml
	pyprojectPath := filepath.Join(outputDir, "pyproject.toml")
	if err := g.writePyproject(pyprojectPath, m); err != nil {
		return nil, err
	}
	files = append(files, "pyproject.toml")

	return files, nil
}

func (g *Generator) writePythonRequirements(path string, deps []manifest.Dependency) error {
	var content strings.Builder
	content.WriteString("# Generated by aigogo\n")
	content.WriteString("# This file was auto-generated from aigogo.json\n\n")

	for _, dep := range deps {
		content.WriteString(fmt.Sprintf("%s%s\n", dep.Package, dep.Version))
	}

	return os.WriteFile(path, []byte(content.String()), 0644)
}

func (g *Generator) writePyproject(path string, m *manifest.Manifest) error {
	var content strings.Builder

	content.WriteString("# Generated by aigogo\n\n")
	content.WriteString("[project]\n")
	content.WriteString(fmt.Sprintf("name = \"%s\"\n", m.Name))
	content.WriteString(fmt.Sprintf("version = \"%s\"\n", m.Version))

	if m.Description != "" {
		content.WriteString(fmt.Sprintf("description = \"%s\"\n", m.Description))
	}
	if m.Author != "" {
		content.WriteString(fmt.Sprintf("authors = [{name = \"%s\"}]\n", m.Author))
	}

	content.WriteString(fmt.Sprintf("requires-python = \"%s\"\n", m.Language.Version))

	if len(m.Dependencies.Runtime) > 0 {
		content.WriteString("dependencies = [\n")
		for _, dep := range m.Dependencies.Runtime {
			content.WriteString(fmt.Sprintf("    \"%s%s\",\n", dep.Package, dep.Version))
		}
		content.WriteString("]\n")
	}

	if len(m.Dependencies.Dev) > 0 {
		content.WriteString("\n[project.optional-dependencies]\n")
		content.WriteString("dev = [\n")
		for _, dep := range m.Dependencies.Dev {
			content.WriteString(fmt.Sprintf("    \"%s%s\",\n", dep.Package, dep.Version))
		}
		content.WriteString("]\n")
	}

	content.WriteString("\n[build-system]\n")
	content.WriteString("requires = [\"setuptools>=61.0\"]\n")
	content.WriteString("build-backend = \"setuptools.build_meta\"\n")

	return os.WriteFile(path, []byte(content.String()), 0644)
}

// JavaScript generation
func (g *Generator) generateJavaScript(m *manifest.Manifest, outputDir string) ([]string, error) {
	pkgPath := filepath.Join(outputDir, "package.json")
	if err := g.writePackageJson(pkgPath, m); err != nil {
		return nil, err
	}
	return []string{"package.json"}, nil
}

func (g *Generator) writePackageJson(path string, m *manifest.Manifest) error {
	var content strings.Builder

	content.WriteString("{\n")
	content.WriteString(fmt.Sprintf("  \"name\": \"%s\",\n", m.Name))
	content.WriteString(fmt.Sprintf("  \"version\": \"%s\",\n", m.Version))

	if m.Description != "" {
		content.WriteString(fmt.Sprintf("  \"description\": \"%s\",\n", m.Description))
	}

	if m.Language.Version != "" {
		content.WriteString("  \"engines\": {\n")
		content.WriteString(fmt.Sprintf("    \"node\": \"%s\"\n", m.Language.Version))
		content.WriteString("  },\n")
	}

	if len(m.Dependencies.Runtime) > 0 {
		content.WriteString("  \"dependencies\": {\n")
		for i, dep := range m.Dependencies.Runtime {
			if i > 0 {
				content.WriteString(",\n")
			}
			content.WriteString(fmt.Sprintf("    \"%s\": \"%s\"", dep.Package, dep.Version))
		}
		content.WriteString("\n  }")
		if len(m.Dependencies.Dev) > 0 {
			content.WriteString(",")
		}
		content.WriteString("\n")
	}

	if len(m.Dependencies.Dev) > 0 {
		content.WriteString("  \"devDependencies\": {\n")
		for i, dep := range m.Dependencies.Dev {
			if i > 0 {
				content.WriteString(",\n")
			}
			content.WriteString(fmt.Sprintf("    \"%s\": \"%s\"", dep.Package, dep.Version))
		}
		content.WriteString("\n  }\n")
	}

	content.WriteString("}\n")

	return os.WriteFile(path, []byte(content.String()), 0644)
}

// Go generation
func (g *Generator) generateGo(m *manifest.Manifest, outputDir string) ([]string, error) {
	modPath := filepath.Join(outputDir, "go.mod")
	if err := g.writeGoMod(modPath, m); err != nil {
		return nil, err
	}
	return []string{"go.mod"}, nil
}

func (g *Generator) writeGoMod(path string, m *manifest.Manifest) error {
	var content strings.Builder

	content.WriteString("// Generated by aigogo\n\n")
	content.WriteString(fmt.Sprintf("module %s\n\n", m.Name))
	content.WriteString(fmt.Sprintf("go %s\n", m.Language.Version))

	if len(m.Dependencies.Runtime) > 0 {
		content.WriteString("\nrequire (\n")
		for _, dep := range m.Dependencies.Runtime {
			content.WriteString(fmt.Sprintf("\t%s %s\n", dep.Package, dep.Version))
		}
		content.WriteString(")\n")
	}

	return os.WriteFile(path, []byte(content.String()), 0644)
}

// Rust generation
func (g *Generator) generateRust(m *manifest.Manifest, outputDir string) ([]string, error) {
	cargoPath := filepath.Join(outputDir, "Cargo.toml")
	if err := g.writeCargoToml(cargoPath, m); err != nil {
		return nil, err
	}
	return []string{"Cargo.toml"}, nil
}

func (g *Generator) writeCargoToml(path string, m *manifest.Manifest) error {
	var content strings.Builder

	content.WriteString("# Generated by aigogo\n\n")
	content.WriteString("[package]\n")
	content.WriteString(fmt.Sprintf("name = \"%s\"\n", m.Name))
	content.WriteString(fmt.Sprintf("version = \"%s\"\n", m.Version))
	content.WriteString("edition = \"2021\"\n")

	if m.Description != "" {
		content.WriteString(fmt.Sprintf("description = \"%s\"\n", m.Description))
	}

	if len(m.Dependencies.Runtime) > 0 {
		content.WriteString("\n[dependencies]\n")
		for _, dep := range m.Dependencies.Runtime {
			content.WriteString(fmt.Sprintf("%s = \"%s\"\n", dep.Package, dep.Version))
		}
	}

	if len(m.Dependencies.Dev) > 0 {
		content.WriteString("\n[dev-dependencies]\n")
		for _, dep := range m.Dependencies.Dev {
			content.WriteString(fmt.Sprintf("%s = \"%s\"\n", dep.Package, dep.Version))
		}
	}

	return os.WriteFile(path, []byte(content.String()), 0644)
}
