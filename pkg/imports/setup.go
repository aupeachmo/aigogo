package imports

import (
	"bufio"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/aupeach/aigogo/pkg/lockfile"
)

const (
	// ImportsDir is the directory containing import symlinks
	ImportsDir = ".aigogo"
	// PythonNamespace is the Python package namespace
	PythonNamespace = "aigogo"
	// JavaScriptScope is the JavaScript package scope
	JavaScriptScope = "@aigogo"
)

// SetupManager manages the .aigogo/imports/ directory structure
type SetupManager struct {
	projectDir string // Project root (where aigogo.lock lives)
	importsDir string // .aigogo/imports/
}

// NewSetupManager creates a new SetupManager for the given project directory
func NewSetupManager(projectDir string) (*SetupManager, error) {
	importsDir := filepath.Join(projectDir, ImportsDir, "imports")

	return &SetupManager{
		projectDir: projectDir,
		importsDir: importsDir,
	}, nil
}

// SetupPythonNamespace creates the Python namespace package structure
// Creates .aigogo/imports/aigogo/__init__.py
func (m *SetupManager) SetupPythonNamespace() error {
	namespaceDir := filepath.Join(m.importsDir, PythonNamespace)
	if err := os.MkdirAll(namespaceDir, 0755); err != nil {
		return fmt.Errorf("failed to create Python namespace directory: %w", err)
	}

	// Create __init__.py as namespace package marker
	initPath := filepath.Join(namespaceDir, "__init__.py")
	initContent := `# Auto-generated by aigogo - do not edit
# Python path is configured via .pth file in site-packages
`

	if err := os.WriteFile(initPath, []byte(initContent), 0644); err != nil {
		return fmt.Errorf("failed to write __init__.py: %w", err)
	}

	return nil
}

// SetupJavaScriptNamespace creates the JavaScript scope directory
// Creates .aigogo/imports/@aigogo/
func (m *SetupManager) SetupJavaScriptNamespace() error {
	scopeDir := filepath.Join(m.importsDir, JavaScriptScope)
	if err := os.MkdirAll(scopeDir, 0755); err != nil {
		return fmt.Errorf("failed to create JavaScript scope directory: %w", err)
	}
	return nil
}

// CreatePackageLink creates a package link for imports.
// For Python: creates a directory symlink .aigogo/imports/aigogo/my_utils -> store/files/
// For JavaScript: creates a real directory with individual file symlinks and a
// generated package.json for proper Node.js module resolution.
func (m *SetupManager) CreatePackageLink(name, language, storePath string) error {
	switch strings.ToLower(language) {
	case "python":
		return m.createPythonLink(name, storePath)
	case "javascript", "typescript":
		return m.createJavaScriptPackage(name, storePath)
	default:
		return fmt.Errorf("unsupported language: %s", language)
	}
}

// createPythonLink creates a directory symlink for a Python package.
func (m *SetupManager) createPythonLink(name, storePath string) error {
	linkDir := filepath.Join(m.importsDir, PythonNamespace)
	linkName := lockfile.NormalizeName(name)

	if err := os.MkdirAll(linkDir, 0755); err != nil {
		return fmt.Errorf("failed to create link directory: %w", err)
	}

	linkPath := filepath.Join(linkDir, linkName)

	// Remove existing link if present
	if _, err := os.Lstat(linkPath); err == nil {
		if err := os.Remove(linkPath); err != nil {
			return fmt.Errorf("failed to remove existing link: %w", err)
		}
	}

	filesDir := filepath.Join(storePath, "files")
	if err := os.Symlink(filesDir, linkPath); err != nil {
		return fmt.Errorf("failed to create symlink: %w", err)
	}

	return nil
}

// createJavaScriptPackage creates a real directory for a JavaScript package
// containing individual file symlinks and a generated package.json with a
// "main" entry point, so that require('@aigogo/pkg') works correctly.
func (m *SetupManager) createJavaScriptPackage(name, storePath string) error {
	linkDir := filepath.Join(m.importsDir, JavaScriptScope)
	if err := os.MkdirAll(linkDir, 0755); err != nil {
		return fmt.Errorf("failed to create link directory: %w", err)
	}

	pkgDir := filepath.Join(linkDir, name)

	// Remove existing package directory if present
	if _, err := os.Lstat(pkgDir); err == nil {
		if err := os.RemoveAll(pkgDir); err != nil {
			return fmt.Errorf("failed to remove existing package directory: %w", err)
		}
	}

	// Create the package directory
	if err := os.MkdirAll(pkgDir, 0755); err != nil {
		return fmt.Errorf("failed to create package directory: %w", err)
	}

	// Symlink each file from the store individually
	filesDir := filepath.Join(storePath, "files")
	err := filepath.Walk(filesDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		relPath, err := filepath.Rel(filesDir, path)
		if err != nil {
			return err
		}

		if relPath == "." {
			return nil
		}

		destPath := filepath.Join(pkgDir, relPath)

		if info.IsDir() {
			return os.MkdirAll(destPath, 0755)
		}

		// Create parent directory if needed
		if err := os.MkdirAll(filepath.Dir(destPath), 0755); err != nil {
			return err
		}

		return os.Symlink(path, destPath)
	})
	if err != nil {
		return fmt.Errorf("failed to create file symlinks: %w", err)
	}

	// Generate package.json with entry point
	entryPoint, err := resolveJSEntryPoint(filesDir)
	if err != nil {
		// No top-level JS files found — check subdirs and warn
		if hasJSFilesInSubdirs(filesDir) {
			fmt.Fprintf(os.Stderr, "⚠ Warning: package %q has no top-level .js files; "+
				"require('@aigogo/%s') will not resolve an entry point. "+
				"Use explicit paths, e.g. require('@aigogo/%s/sub/file').\n", name, name, name)
		}
		return nil
	}

	pkgJSON := map[string]string{
		"name": "@aigogo/" + name,
		"main": entryPoint,
	}
	pkgData, err := json.MarshalIndent(pkgJSON, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal package.json: %w", err)
	}
	pkgData = append(pkgData, '\n')

	pkgJSONPath := filepath.Join(pkgDir, "package.json")
	if err := os.WriteFile(pkgJSONPath, pkgData, 0644); err != nil {
		return fmt.Errorf("failed to write package.json: %w", err)
	}

	return nil
}

// RemovePackageLink removes a package link (symlink for Python, directory for JavaScript)
func (m *SetupManager) RemovePackageLink(name, language string) error {
	var linkPath string

	switch strings.ToLower(language) {
	case "python":
		linkPath = filepath.Join(m.importsDir, PythonNamespace, lockfile.NormalizeName(name))
		if _, err := os.Lstat(linkPath); err == nil {
			return os.Remove(linkPath)
		}
	case "javascript", "typescript":
		linkPath = filepath.Join(m.importsDir, JavaScriptScope, name)
		if _, err := os.Lstat(linkPath); err == nil {
			return os.RemoveAll(linkPath)
		}
	default:
		return fmt.Errorf("unsupported language: %s", language)
	}

	return nil // Already doesn't exist
}

// Clean removes the entire .aigogo/imports/ directory, any installed .pth file,
// and the Node.js register script.
func (m *SetupManager) Clean() error {
	// Remove .pth file before removing imports directory
	if err := RemovePthFile(m.projectDir); err != nil {
		fmt.Fprintf(os.Stderr, "⚠ Warning: failed to remove .pth file: %v\n", err)
	}

	// Remove register script
	if err := RemoveRegisterScript(m.projectDir); err != nil {
		fmt.Fprintf(os.Stderr, "⚠ Warning: failed to remove register script: %v\n", err)
	}

	if _, err := os.Stat(m.importsDir); err == nil {
		return os.RemoveAll(m.importsDir)
	}
	return nil // Already doesn't exist
}

// UpdateGitignore ensures .aigogo/ is in .gitignore
func (m *SetupManager) UpdateGitignore() error {
	gitignorePath := filepath.Join(m.projectDir, ".gitignore")

	// Check if .gitignore exists
	var lines []string
	if _, err := os.Stat(gitignorePath); err == nil {
		// Read existing content
		file, err := os.Open(gitignorePath)
		if err != nil {
			return fmt.Errorf("failed to open .gitignore: %w", err)
		}

		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			line := scanner.Text()
			lines = append(lines, line)

			// Check if .aigogo/ is already ignored
			trimmed := strings.TrimSpace(line)
			if trimmed == ".aigogo/" || trimmed == ".aigogo" || trimmed == "/.aigogo/" || trimmed == "/.aigogo" {
				_ = file.Close()
				return nil // Already ignored
			}
		}
		_ = file.Close()

		if err := scanner.Err(); err != nil {
			return fmt.Errorf("failed to read .gitignore: %w", err)
		}
	}

	// Add .aigogo/ to .gitignore
	file, err := os.OpenFile(gitignorePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("failed to open .gitignore for writing: %w", err)
	}
	defer func() { _ = file.Close() }()

	// Add newline if file doesn't end with one
	if len(lines) > 0 && lines[len(lines)-1] != "" {
		if _, err := file.WriteString("\n"); err != nil {
			return fmt.Errorf("failed to write to .gitignore: %w", err)
		}
	}

	// Add the entry
	if _, err := file.WriteString(".aigogo/\n"); err != nil {
		return fmt.Errorf("failed to write to .gitignore: %w", err)
	}

	return nil
}

// GetProjectDir returns the project root directory path
func (m *SetupManager) GetProjectDir() string {
	return m.projectDir
}

// GetImportsDir returns the imports directory path
func (m *SetupManager) GetImportsDir() string {
	return m.importsDir
}

// GetPythonNamespacePath returns the Python namespace directory path
func (m *SetupManager) GetPythonNamespacePath() string {
	return filepath.Join(m.importsDir, PythonNamespace)
}

// GetJavaScriptScopePath returns the JavaScript scope directory path
func (m *SetupManager) GetJavaScriptScopePath() string {
	return filepath.Join(m.importsDir, JavaScriptScope)
}

// HasPythonPackages checks if there are any Python package links
func (m *SetupManager) HasPythonPackages() bool {
	namespacePath := m.GetPythonNamespacePath()
	entries, err := os.ReadDir(namespacePath)
	if err != nil {
		return false
	}

	// Check for any directories (excluding __init__.py)
	for _, entry := range entries {
		if entry.Name() != "__init__.py" && entry.IsDir() || (entry.Type()&os.ModeSymlink != 0) {
			return true
		}
	}
	return false
}

// HasJavaScriptPackages checks if there are any JavaScript package links
func (m *SetupManager) HasJavaScriptPackages() bool {
	scopePath := m.GetJavaScriptScopePath()
	entries, err := os.ReadDir(scopePath)
	if err != nil {
		return false
	}
	return len(entries) > 0
}

// ListPackageLinks returns all package links organized by language
func (m *SetupManager) ListPackageLinks() (map[string][]string, error) {
	result := make(map[string][]string)

	// Check Python packages
	pythonPath := m.GetPythonNamespacePath()
	if entries, err := os.ReadDir(pythonPath); err == nil {
		for _, entry := range entries {
			if entry.Name() != "__init__.py" {
				result["python"] = append(result["python"], entry.Name())
			}
		}
	}

	// Check JavaScript packages
	jsPath := m.GetJavaScriptScopePath()
	if entries, err := os.ReadDir(jsPath); err == nil {
		for _, entry := range entries {
			result["javascript"] = append(result["javascript"], entry.Name())
		}
	}

	return result, nil
}
