package imports

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

const (
	// registerFileName is the name of the register script
	registerFileName = "register.js"
)

// registerScript is the content of the generated .aigogo/register.js file.
// It programmatically adds the imports directory to NODE_PATH and forces
// Node.js to re-read the path list, enabling require('@aigogo/...') to work.
const registerScript = `// Auto-generated by aigogo â€” do not edit
// Adds .aigogo/imports/ to Node.js module resolution path.
//
// Usage (CommonJS):
//   require('./.aigogo/register');
//
// Usage (preload, works with both CommonJS and ESM):
//   node --require ./.aigogo/register.js app.js
//
const path = require('path');
const importsDir = path.join(__dirname, 'imports');
if (!process.env.NODE_PATH || !process.env.NODE_PATH.split(path.delimiter).includes(importsDir)) {
  process.env.NODE_PATH = importsDir + (process.env.NODE_PATH ? path.delimiter + process.env.NODE_PATH : '');
  require('module').Module._initPaths();
}
`

// InstallRegisterScript writes the .aigogo/register.js file that enables
// Node.js to resolve @aigogo/ scoped packages without manual NODE_PATH setup.
func InstallRegisterScript(projectDir string) error {
	aigogoDir := filepath.Join(projectDir, ImportsDir)
	if err := os.MkdirAll(aigogoDir, 0755); err != nil {
		return fmt.Errorf("failed to create .aigogo directory: %w", err)
	}

	registerPath := filepath.Join(aigogoDir, registerFileName)
	if err := os.WriteFile(registerPath, []byte(registerScript), 0644); err != nil {
		return fmt.Errorf("failed to write register script: %w", err)
	}

	return nil
}

// RemoveRegisterScript removes the .aigogo/register.js file if it exists.
func RemoveRegisterScript(projectDir string) error {
	registerPath := filepath.Join(projectDir, ImportsDir, registerFileName)

	if err := os.Remove(registerPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove register script: %w", err)
	}

	return nil
}

// hasJSFilesInSubdirs checks whether any JS files exist in subdirectories
// of the given directory. Used to provide a helpful warning when entry point
// resolution finds no top-level JS files.
func hasJSFilesInSubdirs(dir string) bool {
	found := false
	_ = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return nil
		}
		rel, _ := filepath.Rel(dir, path)
		if !strings.Contains(rel, string(filepath.Separator)) {
			return nil // skip top-level files
		}
		name := info.Name()
		if strings.HasSuffix(name, ".js") || strings.HasSuffix(name, ".mjs") || strings.HasSuffix(name, ".cjs") {
			found = true
			return filepath.SkipAll
		}
		return nil
	})
	return found
}

// resolveJSEntryPoint determines the "main" file for a JavaScript package
// by examining the top-level files in the store directory.
// Priority: index.js > index.mjs > index.cjs > single file > first file alphabetically.
// Only top-level files are considered; subdirectory files are not checked.
func resolveJSEntryPoint(filesDir string) (string, error) {
	entries, err := os.ReadDir(filesDir)
	if err != nil {
		return "", fmt.Errorf("failed to read files directory: %w", err)
	}

	var jsFiles []string
	hasIndexMjs := false
	hasIndexCjs := false
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		if strings.HasSuffix(name, ".js") || strings.HasSuffix(name, ".mjs") || strings.HasSuffix(name, ".cjs") {
			if name == "index.js" {
				return "index.js", nil
			}
			if name == "index.mjs" {
				hasIndexMjs = true
			}
			if name == "index.cjs" {
				hasIndexCjs = true
			}
			jsFiles = append(jsFiles, name)
		}
	}

	// Prefer index.mjs/index.cjs over arbitrary files
	if hasIndexMjs {
		return "index.mjs", nil
	}
	if hasIndexCjs {
		return "index.cjs", nil
	}

	if len(jsFiles) == 1 {
		return jsFiles[0], nil
	}
	if len(jsFiles) > 0 {
		return jsFiles[0], nil // already sorted by ReadDir
	}

	return "", fmt.Errorf("no JavaScript files found in package")
}
