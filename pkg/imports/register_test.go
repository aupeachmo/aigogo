package imports

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestInstallRegisterScript(t *testing.T) {
	tmpDir := t.TempDir()

	if err := InstallRegisterScript(tmpDir); err != nil {
		t.Fatalf("InstallRegisterScript failed: %v", err)
	}

	registerPath := filepath.Join(tmpDir, ImportsDir, registerFileName)
	content, err := os.ReadFile(registerPath)
	if err != nil {
		t.Fatalf("Failed to read register script: %v", err)
	}

	contentStr := string(content)

	if !strings.Contains(contentStr, "Auto-generated by aigogo") {
		t.Error("register script missing auto-generated marker")
	}

	if !strings.Contains(contentStr, "Module._initPaths") {
		t.Error("register script missing _initPaths call")
	}

	if !strings.Contains(contentStr, "NODE_PATH") {
		t.Error("register script missing NODE_PATH setup")
	}

	if !strings.Contains(contentStr, "path.join(__dirname, 'imports')") {
		t.Error("register script missing imports directory path")
	}
}

func TestInstallRegisterScriptCreatesDir(t *testing.T) {
	tmpDir := t.TempDir()

	// .aigogo dir doesn't exist yet
	aigogoDir := filepath.Join(tmpDir, ImportsDir)
	if _, err := os.Stat(aigogoDir); !os.IsNotExist(err) {
		t.Fatal(".aigogo should not exist before test")
	}

	if err := InstallRegisterScript(tmpDir); err != nil {
		t.Fatalf("InstallRegisterScript failed: %v", err)
	}

	// Should have been created
	if _, err := os.Stat(aigogoDir); os.IsNotExist(err) {
		t.Error(".aigogo directory should have been created")
	}
}

func TestRemoveRegisterScript(t *testing.T) {
	tmpDir := t.TempDir()

	// Install first
	if err := InstallRegisterScript(tmpDir); err != nil {
		t.Fatal(err)
	}

	registerPath := filepath.Join(tmpDir, ImportsDir, registerFileName)
	if _, err := os.Stat(registerPath); os.IsNotExist(err) {
		t.Fatal("register script should exist before removal")
	}

	// Remove
	if err := RemoveRegisterScript(tmpDir); err != nil {
		t.Fatalf("RemoveRegisterScript failed: %v", err)
	}

	if _, err := os.Stat(registerPath); !os.IsNotExist(err) {
		t.Error("register script should have been removed")
	}
}

func TestRemoveRegisterScriptNonExistent(t *testing.T) {
	tmpDir := t.TempDir()

	// Should not error when file doesn't exist
	if err := RemoveRegisterScript(tmpDir); err != nil {
		t.Errorf("RemoveRegisterScript should not error on non-existent file: %v", err)
	}
}

func TestInstallAndRemoveRegisterScriptRoundTrip(t *testing.T) {
	tmpDir := t.TempDir()

	// Install
	if err := InstallRegisterScript(tmpDir); err != nil {
		t.Fatal(err)
	}

	registerPath := filepath.Join(tmpDir, ImportsDir, registerFileName)
	if _, err := os.Stat(registerPath); os.IsNotExist(err) {
		t.Fatal("register script should exist after install")
	}

	// Remove
	if err := RemoveRegisterScript(tmpDir); err != nil {
		t.Fatal(err)
	}

	if _, err := os.Stat(registerPath); !os.IsNotExist(err) {
		t.Error("register script should not exist after removal")
	}
}

func TestResolveJSEntryPointIndexJS(t *testing.T) {
	tmpDir := t.TempDir()

	// Create files including index.js
	_ = os.WriteFile(filepath.Join(tmpDir, "index.js"), []byte("module.exports = {}"), 0644)
	_ = os.WriteFile(filepath.Join(tmpDir, "utils.js"), []byte("module.exports = {}"), 0644)

	entry, err := resolveJSEntryPoint(tmpDir)
	if err != nil {
		t.Fatalf("resolveJSEntryPoint failed: %v", err)
	}

	if entry != "index.js" {
		t.Errorf("entry = %q, want %q", entry, "index.js")
	}
}

func TestResolveJSEntryPointSingleFile(t *testing.T) {
	tmpDir := t.TempDir()

	_ = os.WriteFile(filepath.Join(tmpDir, "tokens.js"), []byte("module.exports = {}"), 0644)

	entry, err := resolveJSEntryPoint(tmpDir)
	if err != nil {
		t.Fatalf("resolveJSEntryPoint failed: %v", err)
	}

	if entry != "tokens.js" {
		t.Errorf("entry = %q, want %q", entry, "tokens.js")
	}
}

func TestResolveJSEntryPointMultipleFiles(t *testing.T) {
	tmpDir := t.TempDir()

	_ = os.WriteFile(filepath.Join(tmpDir, "beta.js"), []byte(""), 0644)
	_ = os.WriteFile(filepath.Join(tmpDir, "alpha.js"), []byte(""), 0644)

	entry, err := resolveJSEntryPoint(tmpDir)
	if err != nil {
		t.Fatalf("resolveJSEntryPoint failed: %v", err)
	}

	// Should return first alphabetically
	if entry != "alpha.js" {
		t.Errorf("entry = %q, want %q", entry, "alpha.js")
	}
}

func TestResolveJSEntryPointNoJSFiles(t *testing.T) {
	tmpDir := t.TempDir()

	_ = os.WriteFile(filepath.Join(tmpDir, "readme.md"), []byte(""), 0644)

	_, err := resolveJSEntryPoint(tmpDir)
	if err == nil {
		t.Error("Expected error when no JS files found")
	}
}

func TestResolveJSEntryPointMjsCjs(t *testing.T) {
	tmpDir := t.TempDir()

	_ = os.WriteFile(filepath.Join(tmpDir, "main.mjs"), []byte(""), 0644)

	entry, err := resolveJSEntryPoint(tmpDir)
	if err != nil {
		t.Fatalf("resolveJSEntryPoint failed: %v", err)
	}

	if entry != "main.mjs" {
		t.Errorf("entry = %q, want %q", entry, "main.mjs")
	}
}

func TestResolveJSEntryPointIndexMjsPriority(t *testing.T) {
	tmpDir := t.TempDir()

	// index.mjs should win over other non-index files
	_ = os.WriteFile(filepath.Join(tmpDir, "alpha.js"), []byte(""), 0644)
	_ = os.WriteFile(filepath.Join(tmpDir, "index.mjs"), []byte(""), 0644)

	entry, err := resolveJSEntryPoint(tmpDir)
	if err != nil {
		t.Fatalf("resolveJSEntryPoint failed: %v", err)
	}

	if entry != "index.mjs" {
		t.Errorf("entry = %q, want %q", entry, "index.mjs")
	}
}

func TestResolveJSEntryPointIndexCjsPriority(t *testing.T) {
	tmpDir := t.TempDir()

	// index.cjs should win over other non-index files
	_ = os.WriteFile(filepath.Join(tmpDir, "zebra.js"), []byte(""), 0644)
	_ = os.WriteFile(filepath.Join(tmpDir, "index.cjs"), []byte(""), 0644)

	entry, err := resolveJSEntryPoint(tmpDir)
	if err != nil {
		t.Fatalf("resolveJSEntryPoint failed: %v", err)
	}

	if entry != "index.cjs" {
		t.Errorf("entry = %q, want %q", entry, "index.cjs")
	}
}

func TestResolveJSEntryPointIndexJSBeatsIndexMjs(t *testing.T) {
	tmpDir := t.TempDir()

	// index.js should win over index.mjs
	_ = os.WriteFile(filepath.Join(tmpDir, "index.js"), []byte(""), 0644)
	_ = os.WriteFile(filepath.Join(tmpDir, "index.mjs"), []byte(""), 0644)

	entry, err := resolveJSEntryPoint(tmpDir)
	if err != nil {
		t.Fatalf("resolveJSEntryPoint failed: %v", err)
	}

	if entry != "index.js" {
		t.Errorf("entry = %q, want %q", entry, "index.js")
	}
}

func TestResolveJSEntryPointIndexMjsBeatsIndexCjs(t *testing.T) {
	tmpDir := t.TempDir()

	// index.mjs should win over index.cjs
	_ = os.WriteFile(filepath.Join(tmpDir, "index.mjs"), []byte(""), 0644)
	_ = os.WriteFile(filepath.Join(tmpDir, "index.cjs"), []byte(""), 0644)

	entry, err := resolveJSEntryPoint(tmpDir)
	if err != nil {
		t.Fatalf("resolveJSEntryPoint failed: %v", err)
	}

	if entry != "index.mjs" {
		t.Errorf("entry = %q, want %q", entry, "index.mjs")
	}
}
