package imports

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestNewSetupManager(t *testing.T) {
	tmpDir := t.TempDir()

	mgr, err := NewSetupManager(tmpDir)
	if err != nil {
		t.Fatalf("NewSetupManager failed: %v", err)
	}

	expectedImports := filepath.Join(tmpDir, ".aigogo", "imports")
	if mgr.GetImportsDir() != expectedImports {
		t.Errorf("ImportsDir = %q, want %q", mgr.GetImportsDir(), expectedImports)
	}
}

func TestSetupPythonNamespace(t *testing.T) {
	tmpDir := t.TempDir()

	mgr, err := NewSetupManager(tmpDir)
	if err != nil {
		t.Fatal(err)
	}

	if err := mgr.SetupPythonNamespace(); err != nil {
		t.Fatalf("SetupPythonNamespace failed: %v", err)
	}

	// Check __init__.py exists
	initPath := filepath.Join(mgr.GetPythonNamespacePath(), "__init__.py")
	if _, err := os.Stat(initPath); os.IsNotExist(err) {
		t.Error("__init__.py not created")
	}

	// Check content
	content, err := os.ReadFile(initPath)
	if err != nil {
		t.Fatal(err)
	}

	if !strings.Contains(string(content), "Auto-generated by aigogo") {
		t.Error("__init__.py doesn't contain auto-generated marker")
	}
	if strings.Contains(string(content), "sys.path") {
		t.Error("__init__.py should not contain sys.path manipulation")
	}
}

func TestSetupJavaScriptNamespace(t *testing.T) {
	tmpDir := t.TempDir()

	mgr, err := NewSetupManager(tmpDir)
	if err != nil {
		t.Fatal(err)
	}

	if err := mgr.SetupJavaScriptNamespace(); err != nil {
		t.Fatalf("SetupJavaScriptNamespace failed: %v", err)
	}

	// Check @aigogo directory exists
	scopePath := mgr.GetJavaScriptScopePath()
	if _, err := os.Stat(scopePath); os.IsNotExist(err) {
		t.Error("@aigogo directory not created")
	}
}

func TestCreatePackageLink(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a fake store path
	storeHash := "abc123"
	storePath := filepath.Join(tmpDir, "store", storeHash)
	filesPath := filepath.Join(storePath, "files")
	if err := os.MkdirAll(filesPath, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(filesPath, "utils.py"), []byte("content"), 0644); err != nil {
		t.Fatal(err)
	}

	// Create setup manager
	projectDir := filepath.Join(tmpDir, "project")
	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatal(err)
	}

	mgr, err := NewSetupManager(projectDir)
	if err != nil {
		t.Fatal(err)
	}

	// Setup Python namespace first
	if err := mgr.SetupPythonNamespace(); err != nil {
		t.Fatal(err)
	}

	// Create link
	if err := mgr.CreatePackageLink("my-utils", "python", storePath); err != nil {
		t.Fatalf("CreatePackageLink failed: %v", err)
	}

	// Check symlink exists with normalized name
	linkPath := filepath.Join(mgr.GetPythonNamespacePath(), "my_utils")
	info, err := os.Lstat(linkPath)
	if err != nil {
		t.Fatalf("Symlink not found: %v", err)
	}

	if info.Mode()&os.ModeSymlink == 0 {
		t.Error("Expected symlink, got regular file/directory")
	}

	// Verify symlink target
	target, err := os.Readlink(linkPath)
	if err != nil {
		t.Fatal(err)
	}
	if target != filesPath {
		t.Errorf("Symlink target = %q, want %q", target, filesPath)
	}
}

func TestCreatePackageLinkJavaScript(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a fake store path with a JS file
	storePath := filepath.Join(tmpDir, "store", "hash123")
	filesPath := filepath.Join(storePath, "files")
	if err := os.MkdirAll(filesPath, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(filesPath, "tokens.js"), []byte("module.exports = {}"), 0644); err != nil {
		t.Fatal(err)
	}

	projectDir := filepath.Join(tmpDir, "project")
	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatal(err)
	}

	mgr, err := NewSetupManager(projectDir)
	if err != nil {
		t.Fatal(err)
	}

	// Setup JS namespace
	if err := mgr.SetupJavaScriptNamespace(); err != nil {
		t.Fatal(err)
	}

	// Create link - JS keeps original name
	if err := mgr.CreatePackageLink("my-utils", "javascript", storePath); err != nil {
		t.Fatalf("CreatePackageLink failed: %v", err)
	}

	// Check package directory exists (real directory, not symlink)
	pkgDir := filepath.Join(mgr.GetJavaScriptScopePath(), "my-utils")
	info, err := os.Lstat(pkgDir)
	if err != nil {
		t.Fatalf("Package directory not found: %v", err)
	}
	if info.Mode()&os.ModeSymlink != 0 {
		t.Error("Expected real directory, got symlink")
	}
	if !info.IsDir() {
		t.Error("Expected directory, got file")
	}

	// Check individual file symlink exists
	filePath := filepath.Join(pkgDir, "tokens.js")
	fileInfo, err := os.Lstat(filePath)
	if err != nil {
		t.Fatalf("File symlink not found: %v", err)
	}
	if fileInfo.Mode()&os.ModeSymlink == 0 {
		t.Error("Expected file to be a symlink")
	}

	// Verify symlink target points to store
	target, err := os.Readlink(filePath)
	if err != nil {
		t.Fatal(err)
	}
	if target != filepath.Join(filesPath, "tokens.js") {
		t.Errorf("Symlink target = %q, want %q", target, filepath.Join(filesPath, "tokens.js"))
	}

	// Check generated package.json
	pkgJSONPath := filepath.Join(pkgDir, "package.json")
	pkgData, err := os.ReadFile(pkgJSONPath)
	if err != nil {
		t.Fatalf("Failed to read package.json: %v", err)
	}
	if !strings.Contains(string(pkgData), `"main": "tokens.js"`) {
		t.Errorf("package.json missing correct main field, got: %s", string(pkgData))
	}
	if !strings.Contains(string(pkgData), `"name": "@aigogo/my-utils"`) {
		t.Errorf("package.json missing correct name field, got: %s", string(pkgData))
	}
}

func TestCreatePackageLinkJavaScriptSubdirs(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a fake store path with files in subdirectories
	storePath := filepath.Join(tmpDir, "store", "hash456")
	filesPath := filepath.Join(storePath, "files")
	if err := os.MkdirAll(filepath.Join(filesPath, "lib"), 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(filesPath, "index.js"), []byte("module.exports = require('./lib/utils')"), 0644); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(filesPath, "lib", "utils.js"), []byte("module.exports = {}"), 0644); err != nil {
		t.Fatal(err)
	}

	projectDir := filepath.Join(tmpDir, "project")
	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatal(err)
	}

	mgr, err := NewSetupManager(projectDir)
	if err != nil {
		t.Fatal(err)
	}

	_ = mgr.SetupJavaScriptNamespace()

	if err := mgr.CreatePackageLink("deep-pkg", "javascript", storePath); err != nil {
		t.Fatalf("CreatePackageLink failed: %v", err)
	}

	pkgDir := filepath.Join(mgr.GetJavaScriptScopePath(), "deep-pkg")

	// Check index.js symlink
	if _, err := os.Lstat(filepath.Join(pkgDir, "index.js")); err != nil {
		t.Error("index.js symlink not found")
	}

	// Check subdirectory file symlink
	if _, err := os.Lstat(filepath.Join(pkgDir, "lib", "utils.js")); err != nil {
		t.Error("lib/utils.js symlink not found")
	}

	// Check package.json uses index.js as main
	pkgData, err := os.ReadFile(filepath.Join(pkgDir, "package.json"))
	if err != nil {
		t.Fatal(err)
	}
	if !strings.Contains(string(pkgData), `"main": "index.js"`) {
		t.Errorf("package.json should use index.js as main, got: %s", string(pkgData))
	}
}

func TestRemovePackageLinkJavaScript(t *testing.T) {
	tmpDir := t.TempDir()

	storePath := filepath.Join(tmpDir, "store", "hash")
	filesPath := filepath.Join(storePath, "files")
	if err := os.MkdirAll(filesPath, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(filesPath, "index.js"), []byte(""), 0644); err != nil {
		t.Fatal(err)
	}

	projectDir := filepath.Join(tmpDir, "project")
	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatal(err)
	}

	mgr, err := NewSetupManager(projectDir)
	if err != nil {
		t.Fatal(err)
	}

	_ = mgr.SetupJavaScriptNamespace()
	_ = mgr.CreatePackageLink("js-pkg", "javascript", storePath)

	pkgDir := filepath.Join(mgr.GetJavaScriptScopePath(), "js-pkg")
	if _, err := os.Stat(pkgDir); os.IsNotExist(err) {
		t.Fatal("Package directory should exist before removal")
	}

	if err := mgr.RemovePackageLink("js-pkg", "javascript"); err != nil {
		t.Fatalf("RemovePackageLink failed: %v", err)
	}

	if _, err := os.Stat(pkgDir); !os.IsNotExist(err) {
		t.Error("Package directory should be removed")
	}
}

func TestCreatePackageLinkUnsupportedLanguage(t *testing.T) {
	tmpDir := t.TempDir()

	mgr, err := NewSetupManager(tmpDir)
	if err != nil {
		t.Fatal(err)
	}

	err = mgr.CreatePackageLink("pkg", "rust", "/some/path")
	if err == nil {
		t.Error("Expected error for unsupported language")
	}
}

func TestClean(t *testing.T) {
	tmpDir := t.TempDir()

	mgr, err := NewSetupManager(tmpDir)
	if err != nil {
		t.Fatal(err)
	}

	// Setup namespaces
	if err := mgr.SetupPythonNamespace(); err != nil {
		t.Fatal(err)
	}
	if err := mgr.SetupJavaScriptNamespace(); err != nil {
		t.Fatal(err)
	}

	// Verify directories exist
	if _, err := os.Stat(mgr.GetImportsDir()); os.IsNotExist(err) {
		t.Fatal("Imports directory doesn't exist before clean")
	}

	// Clean
	if err := mgr.Clean(); err != nil {
		t.Fatalf("Clean failed: %v", err)
	}

	// Verify cleaned
	if _, err := os.Stat(mgr.GetImportsDir()); !os.IsNotExist(err) {
		t.Error("Imports directory still exists after clean")
	}
}

func TestCleanNonExistent(t *testing.T) {
	tmpDir := t.TempDir()

	mgr, err := NewSetupManager(tmpDir)
	if err != nil {
		t.Fatal(err)
	}

	// Clean when directory doesn't exist should not error
	if err := mgr.Clean(); err != nil {
		t.Errorf("Clean failed on non-existent directory: %v", err)
	}
}

func TestUpdateGitignore(t *testing.T) {
	tmpDir := t.TempDir()

	mgr, err := NewSetupManager(tmpDir)
	if err != nil {
		t.Fatal(err)
	}

	// Update gitignore (creates new file)
	if err := mgr.UpdateGitignore(); err != nil {
		t.Fatalf("UpdateGitignore failed: %v", err)
	}

	// Check content
	gitignorePath := filepath.Join(tmpDir, ".gitignore")
	content, err := os.ReadFile(gitignorePath)
	if err != nil {
		t.Fatal(err)
	}

	if !strings.Contains(string(content), ".aigogo/") {
		t.Error(".gitignore doesn't contain .aigogo/")
	}

	// Update again - should not duplicate
	if err := mgr.UpdateGitignore(); err != nil {
		t.Fatalf("Second UpdateGitignore failed: %v", err)
	}

	content2, _ := os.ReadFile(gitignorePath)
	count := strings.Count(string(content2), ".aigogo/")
	if count != 1 {
		t.Errorf(".aigogo/ appears %d times, want 1", count)
	}
}

func TestUpdateGitignoreExisting(t *testing.T) {
	tmpDir := t.TempDir()

	// Create existing .gitignore
	gitignorePath := filepath.Join(tmpDir, ".gitignore")
	initialContent := "node_modules/\n*.log\n"
	if err := os.WriteFile(gitignorePath, []byte(initialContent), 0644); err != nil {
		t.Fatal(err)
	}

	mgr, err := NewSetupManager(tmpDir)
	if err != nil {
		t.Fatal(err)
	}

	if err := mgr.UpdateGitignore(); err != nil {
		t.Fatalf("UpdateGitignore failed: %v", err)
	}

	content, _ := os.ReadFile(gitignorePath)
	contentStr := string(content)

	// Should have original content
	if !strings.Contains(contentStr, "node_modules/") {
		t.Error("Original content lost")
	}

	// Should have new entry
	if !strings.Contains(contentStr, ".aigogo/") {
		t.Error(".aigogo/ not added")
	}
}

func TestUpdateGitignoreAlreadyIgnored(t *testing.T) {
	tmpDir := t.TempDir()

	// Create .gitignore that already has .aigogo
	gitignorePath := filepath.Join(tmpDir, ".gitignore")
	initialContent := "node_modules/\n.aigogo/\n*.log\n"
	if err := os.WriteFile(gitignorePath, []byte(initialContent), 0644); err != nil {
		t.Fatal(err)
	}

	mgr, err := NewSetupManager(tmpDir)
	if err != nil {
		t.Fatal(err)
	}

	if err := mgr.UpdateGitignore(); err != nil {
		t.Fatalf("UpdateGitignore failed: %v", err)
	}

	// Content should be unchanged
	content, _ := os.ReadFile(gitignorePath)
	if string(content) != initialContent {
		t.Error("Content was modified when .aigogo/ was already present")
	}
}

func TestRemovePackageLink(t *testing.T) {
	tmpDir := t.TempDir()

	// Create store and project
	storePath := filepath.Join(tmpDir, "store", "hash")
	filesPath := filepath.Join(storePath, "files")
	if err := os.MkdirAll(filesPath, 0755); err != nil {
		t.Fatal(err)
	}

	projectDir := filepath.Join(tmpDir, "project")
	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatal(err)
	}

	mgr, err := NewSetupManager(projectDir)
	if err != nil {
		t.Fatal(err)
	}

	// Setup and create link
	_ = mgr.SetupPythonNamespace()
	_ = mgr.CreatePackageLink("test-pkg", "python", storePath)

	// Verify link exists
	linkPath := filepath.Join(mgr.GetPythonNamespacePath(), "test_pkg")
	if _, err := os.Lstat(linkPath); err != nil {
		t.Fatal("Link should exist")
	}

	// Remove link
	if err := mgr.RemovePackageLink("test-pkg", "python"); err != nil {
		t.Fatalf("RemovePackageLink failed: %v", err)
	}

	// Verify removed
	if _, err := os.Lstat(linkPath); !os.IsNotExist(err) {
		t.Error("Link should not exist after removal")
	}
}

func TestListPackageLinks(t *testing.T) {
	tmpDir := t.TempDir()

	// Create store with files for both languages
	storePath := filepath.Join(tmpDir, "store")
	filesPath := filepath.Join(storePath, "files")
	if err := os.MkdirAll(filesPath, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(filesPath, "index.js"), []byte(""), 0644); err != nil {
		t.Fatal(err)
	}

	projectDir := filepath.Join(tmpDir, "project")
	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatal(err)
	}

	mgr, err := NewSetupManager(projectDir)
	if err != nil {
		t.Fatal(err)
	}

	// Setup namespaces and create links
	_ = mgr.SetupPythonNamespace()
	_ = mgr.SetupJavaScriptNamespace()
	_ = mgr.CreatePackageLink("py-utils", "python", storePath)
	_ = mgr.CreatePackageLink("js-utils", "javascript", storePath)

	// List
	links, err := mgr.ListPackageLinks()
	if err != nil {
		t.Fatalf("ListPackageLinks failed: %v", err)
	}

	if len(links["python"]) != 1 {
		t.Errorf("Python packages = %d, want 1", len(links["python"]))
	}

	if len(links["javascript"]) != 1 {
		t.Errorf("JavaScript packages = %d, want 1", len(links["javascript"]))
	}
}
